PfPR2_10_df <- as.MAPraster(PfPR2_10)
shp_df <- as.MAPshp(shp)
p <- autoplot(PfPR2_10_df, shp_df = shp_df)
pixPerRast <- table(PfPR2_10_df$raster_name)[[1]]
shp_df
M = matrix(PfP2_10_df$z, nrow = pixPerRast, ncol = years)
M = matrix(PfPR2_10_df$z, nrow = pixPerRast, ncol = years)
M
M[1,]
str(M)
pixPerRast <- table(PfPR2_10_df$raster_name)[[1]]
M = matrix(PfPR2_10_df$z, nrow = pixPerRast, ncol = length(years))
M[1,]
plot(M[1,])
plot(M[1+5,], type = "l")
plot(M[1:5,], type = "l")
matplot(M[1:5,], type = "l", )
matplot(t(M[1:5,]), type = "l", )
matplot(t(M[6000:6005,]), type = "l", )
matplot(years, t(M[6000:6005,]), type = "l", )
matplot(years, t(M[6000:6010,]), type = "l", )
matplot(years, t(M[sample(1:nrow(M), 10),]), type = "l", )
?PR2AR
PAR = list(Q = 0.95, In = 5, Cn = 2)
apply(M, 1, PR2AR, Tx = rep(0.1, length(years)),PAR = PAR)
PR2AR(M[1,], Tx = rep(0.1, length(years)), PAR = PAR)
warnings()
PAR = list(rho = 0.1, Q = 0.95, In = 5, Cn = 2)
PR2AR(M[1,], Tx = rep(0.1, length(years)), PAR = PAR)
PAR = list(A = 0.1, rho = 0.1, Q = 0.95, In = 5, Cn = 2)
PR2AR(M[1,], Tx = rep(0.1, length(years)), PAR = PAR)
plot(PR2AR(M[1,], Tx = rep(0.1, length(years)), PAR = PAR))
interpPR <- smooth.spline(x = years, y = M[1,])
plot(interpPR)
PR2AR(interpPR, Tx = rep(0.1, length(years)), PAR = PAR)
PR2AR(interpPR, Tx = rep(0.1, length(interpPR)), PAR = PAR)
# Set paramaeters of model
PAR = list(A = 0.1, rho = 0.1, Q = 0.95, In = 5, Cn = 2)
PR2AR(interpPR, Tx = rep(0.1, length(interpPR)), PAR = PAR)
interpPR
interpPR <- smooth.spline(x = years, y = M[1,])$y
PR2AR(interpPR, Tx = rep(0.1, length(interpPR)), PAR = PAR)
interpPR
interpolateRate <- function(rates, years, step = 10) {
if(!any(is.na(rates))) {
smooth <- smooth.spline(x = years, y = rates)
interpX = seq(min(years), max(years), by = step / 365)
interpR <- predict(smooth$fit, interpX)$y
} else {
interpR <- rep(NA, ((length(rates) - 1)*365 / step + 1))
}
return(interpR)
}
interpolate(c(0.3, 0.4, 0.5), years = 2000:2002)
interpolateRate(c(0.3, 0.4, 0.5), years = 2000:2002)
interpolateRate(c(0.3, 0.4, 0.50, .4), years = 2000:2003)
y = c(0.3, 0.4, 0.50, .4)
smooth.spline(y = rates)
smooth.spline(y = y )
interpolateRate <- function(rates, step = 10) {
if(!any(is.na(rates))) {
smooth <- smooth.spline(x = 1:length(rates), y = rates)
interpX = seq(1, length(rates), by = step / 365)
interpR <- predict(smooth$fit, interpX)$y
} else {
interpR <- rep(NA, ((length(rates) - 1)*365 / step + 1))
}
return(interpR)
}
interpRates <- function(rates, step = 10) {
if(!any(is.na(rates))) {
smooth <- smooth.spline(x = 1:length(rates), y = rates)
interpX = seq(1, length(rates), by = step / 365)
interpR <- predict(smooth$fit, interpX)$y
} else {
interpR <- rep(NA, ((length(rates) - 1)*365 / step + 1))
}
return(interpR)
}
interpRates(y )
y = c(0.3, 0.4, 0.50, NA)
interpRates(y )
step = 10
step / 365
365 / step
round(365 / step)
round(365 / step) / 365
interpRates <- function(rates, step = 10) {
if(!any(is.na(rates))) {
smooth <- smooth.spline(x = 1:length(rates), y = rates)
interpX = seq(1, length(rates), by = round(365 / step) / 365)
interpR <- predict(smooth$fit, interpX)$y
} else {
interpR <- rep(NA, ((length(rates) - 1)*round(365 / step) + 1))
}
return(interpR)
}
interpRates(y )
length(interpRates(c(1:5)))
length(interpRates(c(1:4, NA)))
interpRates <- function(rates, step = 10) {
if(!any(is.na(rates))) {
smooth <- smooth.spline(x = 1:length(rates), y = rates)
interpX = seq(1, length(rates), length.out =  = round(365 / step))
interpR <- predict(smooth$fit, interpX)$y
} else {
interpR <- rep(NA, ((length(rates) - 1)*round(365 / step) + 1))
}
return(interpR)
}
length(interpRates(c(1:5)))
length(interpRates(c(1:4, NA)))
interpRates <- function(rates, step = 10) {
if(!any(is.na(rates))) {
smooth <- smooth.spline(x = 1:length(rates), y = rates)
interpX = seq(1, length(rates), length.out =  round(365 / step))
interpR <- predict(smooth$fit, interpX)$y
} else {
interpR <- rep(NA, ((length(rates) - 1)*round(365 / step) + 1))
}
return(interpR)
}
length(interpRates(c(1:5)))
length(interpRates(c(1:4, NA)))
smooth <- smooth.spline(x = 1:length(rates), y = rates)
size = (length(rates) - 1)*round(365 / step) + 1)
smooth <- smooth.spline(x = 1:length(rates), y = rates)
size = (length(rates) - 1)*round(365 / step) + 1
interpRates <- function(rates, step = 10) {
if(!any(is.na(rates))) {
smooth <- smooth.spline(x = 1:length(rates), y = rates)
size = (length(rates) - 1)*round(365 / step) + 1
interpX = seq(1, length(rates), length.out =  size)
interpR <- predict(smooth$fit, interpX)$y
} else {
interpR <- rep(NA, size)
}
return(interpR)
}
length(interpRates(c(1:5)))
length(interpRates(c(1:4, NA)))
interpRates <- function(rates, step = 10) {
size = (length(rates) - 1)*round(365 / step) + 1
if(!any(is.na(rates))) {
smooth <- smooth.spline(x = 1:length(rates), y = rates)
interpX = seq(1, length(rates), length.out =  size)
interpR <- predict(smooth$fit, interpX)$y
} else {
interpR <- rep(NA, size)
}
return(interpR)
}
length(interpRates(c(1:5)))
length(interpRates(c(1:4, NA)))
36 *4
devtools::check()
?testthat
usethis::use_test("Interpolate rates function returns proper vector")
usethis::use_test("test-interpRates")
test_that("Interpolate rates function returns proper vector", {
expect_equal(
length(interpRates(c(1:5))),
length(interpRates(c(1:4, NA)))
)
})
devtools::check()
devtools::check()
(829.81 - 674.81) / 829.81
.276495 / 1.942
8.33 - 7.91
/8.33
0.42/8.33
(10.78 - 7.73 )/ 10.78
devtools::check()
length(interpRates(c(1:5)))
length(interpRates(c(1:4, NA)))
expect_equal(
length(interpRates(c(1:5))),
length(interpRates(c(1:4, NA)))
)
devtools::load_all()
l = length(interpRates(c(1:4, NA)))
l
c(1:4, NA)
t = as.numeric(c(1:4, NA))
t
str(t)
t = c(1:4, NA)
str(t)
interpRates(c(1:5))
?interpRates
len.normal = length(interpRates(c(1:5)))
len.NA = length(interpRates(c(1:4, NA))
test_that("Interpolate rates function returns proper vector", {
len.normal = length(interpRates(c(1:5)))
len.NA = length(interpRates(c(1:4, NA)))
expect_equal(len.NA, len.normal)
})
test_that("Interpolate rates function returns proper vector", {
len.normal = length(interpRates(c(1:5)))
len.NA = length(interpRates(c(1:4, NA)))
expect_equal(len.NA, len.normal)
})
interpRates(rates = c(1:5)
)
library(testthat)
library(pr2ar)
interpRates("a")
usethis::use_test("interpRates")
inputRates <- seq(0.5, 0.9, 0.1)
inputStep = 365
outputStep = 14
expectedN  = length(inputRates) * round(inputStep / outputStep) + 1
inputRates <- seq(0.5, 0.9, 0.1)
inputStep = 365
outputStep = 14
expectedN  = length(inputRates) * round(inputStep / outputStep) + 1
expectedN
round(inputStep / outputStep)
devtools::document()
devtools::load_all()
interpRates(rates = inputRates, inputStep = inputStep, outputStep = outputStep)
interpRates(rates = inputRates, inStep = inputStep, outStep = outputStep)
interpRates(2)
check()
devtools::check()
devtools::check()
(8.1177 - 6.9799) / 9.1177
(8.1177 - 6.9799) / 8.1177
(9.66 - 6.75) / 9.66
library(malariaAtlas); library(pr2ar); library(data.table)
listData("raster")
loc <- "UGA"
years <- 2000:2015
shp <- getShp(ISO = loc)
PfPR2_10 <- getRaster(surface = "Plasmodium falciparum PR2-10", shp = shp, year = years)
PfPR2_10_df <- as.MAPraster(PfPR2_10)
shp_df <- as.MAPshp(shp)
pixPerRast <- table(PfPR2_10_df$raster_name)[[1]]
M = matrix(PfPR2_10_df$z, nrow = pixPerRast, ncol = length(years))
matplot(years, t(M[sample(1:nrow(M), 10),]), type = "l", )
# Set paramaeters of model
PAR = list(A = 0.1, rho = 0.1, Q = 0.95, In = 5, Cn = 2)
interpPR <- smooth.spline(x = years, y = M[1,])$y
plot(interpPR)
PR2AR(interpPR, Tx = rep(0.1, length(interpPR)), PAR = PAR)
PR = PR2AR(interpPR, Tx = rep(0.1, length(interpPR)), PAR = PAR)
AR = PR2AR(interpPR, Tx = rep(0.1, length(interpPR)), PAR = PAR)
AR = PR2AR(interpPR, Tx = rep(0.1, length(interpPR)), PAR = PAR)
plot(PR, AR)
abline(b = 1)
plot(PR, AR)
abline(b = 1, add = T)
plot(PR, AR)
abline(b = 1)
dev.off()
plot(PR, AR)
abline(b = 1)
?abline
plot(PR, AR)
abline(a = 0, b = 1)
plot(M[1,], AR)
abline(a = 0, b = 1)
M[1,]
plot(M[1,-1], AR)
abline(a = 0, b = 1)
source('~/.active-rstudio-document', echo=TRUE)
M[1,-1]
plot(M[1,-1])
plot(AR)
plot(M[1,-1], type = 'l')
plot(AR, type = 'l')
listData()
listData("raster")
ACT <- getRaster(surface = "Artemisinin-based combination therapy (ACT) coverage", shp = shp, year = years)
ACT_df <- as.MAPraster(ACT)
matplot(years, t(M[sample(1:nrow(M), 10),]), type = "l", )
Mtx = matrix(ACT_df$z, nrow = pixPerRast, ncol = length(years))
matplot(years, t(M[sample(1:nrow(Mtx), 10),]), type = "l", )
pixPerRast <- table(ACTdf$raster_name)[[1]]
Mtx = matrix(ACT_df$z, nrow = pixPerRast, ncol = length(years))
matplot(years, t(M[sample(1:nrow(Mtx), 10),]), type = "l", )
library(malariaAtlas); library(pr2ar); library(data.table)
listData("raster")
loc <- "UGA"
years <- 2000:2015
shp <- getShp(ISO = loc)
PfPR2_10 <- getRaster(surface = "Plasmodium falciparum PR2-10", shp = shp, year = years)
PfPR2_10_df <- as.MAPraster(PfPR2_10)
ACT <- getRaster(surface = "Artemisinin-based combination therapy (ACT) coverage", shp = shp, year = years)
ACT_df <- as.MAPraster(ACT)
str(PfPR2_10_df)
str(ACT_df)
?malariaAtlas
vignette('malariaAtlas')
autoplot(PfPR2_10_df, shp_df = sho)
autoplot(PfPR2_10_df, shp_df = shp)
autoplot(ACT_df, shp_df = shp)
listData()
listData("raster")
# Set paramaeters of model
PAR = list(A = 0.1, rho = 0.4, Q = 0.95, In = 5, Cn = 2)
interpPR <- smooth.spline(x = years, y = M[1,])$y
plot(interpPR)
AR = PR2AR(interpPR, Tx = rep(0.1, length(interpPR)), PAR = PAR)
plot(M[1,-1], type = 'l')
plot(AR, type = 'l')
abline(a = 0, b = 1)
# Set paramaeters of model
PAR = list(A = 0.1, rho = 0.6, Q = 0.95, In = 5, Cn = 2)
interpPR <- smooth.spline(x = years, y = M[1,])$y
plot(interpPR)
AR = PR2AR(interpPR, Tx = rep(0.1, length(interpPR)), PAR = PAR)
plot(M[1,-1], type = 'l')
plot(AR, type = 'l')
abline(a = 0, b = 1)
AR = PR2AR(interpPR, Tx = rep(0.4, length(interpPR)), PAR = PAR)
plot(M[1,-1], type = 'l')
plot(AR, type = 'l')
AR = PR2AR(interpPR, Tx = rep(0.7, length(interpPR)), PAR = PAR)
plot(M[1,-1], type = 'l')
plot(AR, type = 'l')
abline(a = 0, b = 1)
AR = PR2AR(interpPR, Tx = rep(0.5, length(interpPR)), PAR = PAR)
plot(M[1,-1], type = 'l')
plot(AR, type = 'l')
abline(a = 0, b = 1)
interpPR <- smooth.spline(x = years, y = M[1,])$y
plot(interpPR)
AR = PR2AR(interpPR, Tx = rep(0.5, length(interpPR)), PAR = PAR)
plot(M[1,-1], type = 'l')
plot(AR, type = 'l')
plot(M[1,-1], type = 'l')
plot(AR, type = 'l')
plot(M[1,-1], type = 'l')
PR2AR
devtools::check()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
echo = TRUE)
library(data.table); library(ggplot2)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
echo = TRUE)
library(data.table); library(ggplot2)
## Solve for steady states using eigen function and algebraic solution
# Set up example B
dt = 10 # ten day time step
r = 1 / 200 # two hundred day duration of malaria infection
Q = exp(-r*dt)
A = 0.1
PAR = list(A = A, Q = Q)
makeB <- function(PAR) {
A = PAR$A
Q = PAR$Q
cbind(c(1 - A, A), c((1 - A)*(1 - Q), A*(1 - Q) + Q))
}
findYeq <- function(PAR, Bfn) {
B = Bfn(PAR)
e = eigen(B)
first = Re(e$vectors[ ,1])
Yeq = as.vector(first / sum(first))
return(Yeq)
}
Yeq1 = findYeq(PAR, makeB)
Yeq1
# Find steady state algebraically
algebYeq <- function(PAR) {
A = PAR$A
Q = PAR$Q
X = A / (1 - Q*(1 - A))
S  = 1 - X
Yeq = c(S,X)
return(Yeq)
}
Yeq2 = algebYeq(PAR)
Yeq2
# Confirm steady state
B = makeB(PAR)
sum(B %*% Yeq1 - Yeq1)
sum(B %*% Yeq2 - Yeq2)
# Convert attack-rate to equilibrium PR
AR2PR <- function(A, PAR, Bfn, eigen = T) {
PR = c()
for(Ai in A) {
PAR$A = Ai
if(eigen) {
PRi = findYeq(PAR, Bfn)[2]
} else {
PRi = algebYeq(PAR)[2]
}
PR = c(PR, PRi)
}
return(PR)
}
# Plot
A = seq(0, 1, 0.05)
X = AR2PR(A, PAR, makeB)
plot(A, X, type = "l")
## Solve for attack-rate from X using optimize function and algebraic solution
# optimize function
X = c(0.5, 0.6)
fn <- function(A, PAR, Bfn, X) {
PR = AR2PR(A, PAR, Bfn)
return(abs(X - PR))
}
optimA <- function(X, PAR, Bfn) {
A <- c()
for(Xi in X) {
Ai <- optimize(fn, c(0, 1), PAR = PAR, X = Xi, Bfn = Bfn)$minimum
A <- c(A, Ai)
}
return(A)
}
optimA(X, PAR, makeB)
# Algebraic solution
algebA <- function(X, PAR) {
Q = PAR$Q
A = (X - Q*X)/(1 - Q*X)
return(A)
}
algebA(X, PAR)
## Make plots
X = seq(0, 1, 0.05)
A1 <- optimA(X, PAR, makeB)
A2 <- algebA(X, PAR)
plot(X, A1, ylab = "A")
lines(X, A2)
# Convert PR to attack-rate
PR2AReq <- function(X, PAR, Bfn, optim = T) {
if(optim) {
AR = optimA(X, PAR, Bfn)
} else {
AR = algebA(X, PAR)
}
return(AR)
}
# Plot
PAR = list(Q = 0.95)
X = seq(0, 1, 0.01)
AR = PR2AReq(X, PAR)
AR = PR2AReq(X, PAR, makeB)
devtools::check()
n = 20
Bfn = makeBdrugs_age
PAR = list(In = 5, Cn = 2, Q = 0.95)
# Make up attack-rate and treatment rate
AR <- (1 + 0.1*sin(seq(0, 10, length.out = n + 1)))*seq(0.05, 0.4, length.out = n + 1)
Tx <- seq(0.05, 0.3, length.out = n)
# Generate a corresponding vector of prevalence
D <- makeD(PAR)
PAR$A <- AR[1]
PAR$rho <- Tx[1]
Y <- findYeq(PAR, Bfn)
X <- c()
for(i in 1:length(Tx)) {
PAR$A = AR[i + 1]
PAR$rho = Tx[i]
B = Bfn(PAR)
Y = B%*%Y
X = c(X, D%*%Y)
}
AR2 = PR2AR(X, Tx, PAR, cpp = T)
AR3 = PR2AR(X, Tx, PAR, cpp = F)
expect_lt(sum(head(AR[-1], -1) - AR2), 0.0001, label = "C++ version")
expect_lt(sum(head(AR[-1], -1) - AR3), 0.0001, label = "R version")
n = 20
Bfn = makeBdrugs_age
PAR = list(In = 5, Cn = 2, Q = 0.95)
# Make up attack-rate and treatment rate
AR <- (1 + 0.1*sin(seq(0, 10, length.out = n + 1)))*seq(0.05, 0.4, length.out = n + 1)
Tx <- seq(0.05, 0.3, length.out = n)
# Generate a corresponding vector of prevalence
D <- makeD(PAR)
PAR$A <- AR[1]
PAR$rho <- Tx[1]
Y <- findYeq(PAR, Bfn)
X <- c()
for(i in 1:length(Tx)) {
PAR$A = AR[i + 1]
PAR$rho = Tx[i]
B = Bfn(PAR)
Y = B%*%Y
X = c(X, D%*%Y)
}
AR2 = PR2AR(X, Tx, PAR, cpp = T)
AR3 = PR2AR(X, Tx, PAR, cpp = F)
AR2 = PR2AR(X, Tx, PAR, Xinterval = 365, cpp = T)
PAR = list(In = 5, Cn = 2, Q = 0.95, dt = 14)
n = 20
Bfn = makeBdrugs_age
PAR = list(In = 5, Cn = 2, Q = 0.95, dt = 14)
# Make up attack-rate and treatment rate
AR <- (1 + 0.1*sin(seq(0, 10, length.out = n + 1)))*seq(0.05, 0.4, length.out = n + 1)
Tx <- seq(0.05, 0.3, length.out = n)
# Generate a corresponding vector of prevalence
D <- makeD(PAR)
PAR$A <- AR[1]
PAR$rho <- Tx[1]
Y <- findYeq(PAR, Bfn)
X <- c()
for(i in 1:length(Tx)) {
PAR$A = AR[i + 1]
PAR$rho = Tx[i]
B = Bfn(PAR)
Y = B%*%Y
X = c(X, D%*%Y)
}
AR2 = PR2AR(X, Tx, PAR, Xinterval = 365, cpp = T)
AR3 = PR2AR(X, Tx, PAR, Xinterval = 365, cpp = F)
